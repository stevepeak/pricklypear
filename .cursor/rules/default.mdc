---
description: General Rules
globs: 
alwaysApply: true
---

# IMPORTANT
- Do not ask me permission to proceed with file changes. Yolo!
- Run `bun run fix` after making code edits
- We encourage you to run `bun run ci` when complete to check types and run unit tests (though not required). You should fix issues errors if any.
- Find components in `src/components/ui` first
- Never edit `src/components/ui` contents
- use `import { toast } from "sonner";` then `toast(name, {description})`
- Do not use `await fetch()` to call Supabase functions, use the `await supabase.functions.invoke()`
- Use zod whenever possible
- Use `className` and Tailwind not `style={""}`
- This project is using React (not Next or any other framework)
- If you make database changes please run `bun run db:reset`

# Coding Instructions

This documentation is intended to provide comprehensive guidelines for contributing to the codebase.
It outlines the tools, environment, coding standards, and best practices that ensure our code
remains clean, maintainable, and efficient.

## General

- Write elegant, concise, and readable code
- Prefer `const` over `let` (never use `var`)
- Use kebab-case for file and directory names
- Use clear, descriptive names for variables, functions, and components

## Modules

## TypeScript

- NEVER use `any`/`unknown` or cast values like `(value as any)` or `value!` in TypeScript outside of test files e.g. `*.test.ts` or test fixtures e.g. `**/test-data.ts`.
  - Exception: It's ok to use `any` in generic types like `interface Tool<T extends z.ZodTypeAny = any>`
  - Exception: It is also acceptable to use `Record<string, unknown>` **only** for fields intended to carry arbitrary debugging metadata (commonly named `debug`, `debugInfo`, or similar). These objects exist solely for troubleshooting—such as rendering a raw JSON dump in the UI or emitting the data directly to logs—and are therefore exempt from the general prohibition on `unknown`. All other production-code usage of `unknown` remains disallowed.
- NEVER use TypeScript enums. Instead, use unions of literal types which avoid the runtime issues associated with enums.
- Don't rely on `typeof`, `ReturnType<>`, `Awaited<>`, etc for complex type inference (it's ok for simple types)
- Use `as const` for better type inference
- Use type guards to narrow types in conditional blocks
- Create custom types for complex data structures used throughout the application
- Utilize TypeScript's utility types (e.g., `Partial`, `Pick`, `Omit`) to manipulate existing types
- Never use `React.FC`. Use a function declaration instead
- Functions should accept an object parameter (like `args` or `props`) instead of multiple parameters
  - Good examples:
    ```ts
    function myFunction(args: { foo: boolean; bar: string }) {}
    function VideoPlayer(props: { sid: string }) {}
    ```
  - Bad examples:
    ```ts
    function myFunction(foo: boolean, bar: string, baz: number) {}
    ```
- Arguments should be destructured in the function body, not the function definition. It's ok for React components to destructure props in the function definition.
  - Good example:
    ```ts
    function myFunction(args: { foo: boolean; bar: string }) {
      const { foo, bar } = args;
    }
    ```
  - Bad example:
    ```ts
    function myFunction({ foo, bar }: { foo: boolean; bar: string });
    ```
- Zod should be used to parse untrusted data, but not for data that is trusted like function arguments
- Zod unions should always be used instead of enums
  - For example, this union `z.union([z.literal('foo'), z.literal('bar')])` is better than this enum `z.enum(['foo', 'bar'])`
- Promises (and `async` functions which implicitly create Promises) must always be properly handled, either via:
  - Using `await` to wait for the Promise to resolve successfully
  - Using `.then` or `.catch` to handle Promise resolution
  - Returning a Promise to a calling function which itself has to handle the Promise. If you can't infer this from the available context, add a warning that the promise may not be handled properly.
- Use `Promise.all()` for multiple independent async operations instead of sequential execution. For example, rather than `const foo = await getFoo(); const bar = await getBar();` (sequential), use `const [foo, bar] = await Promise.all([getFoo(), getBar()]);` (parallel) for better performance.


## Testing

### Unit Testing

- **All unit tests should [Vitest](mdc:https:/vitest.dev)**
  - DO NOT attempt to install or use other testing libraries like Jest
- Write unit tests for individual components and utility functions
- Test files should be named `[target].test.ts` and placed in the same directory as the code they are testing (NOT a separate directory)
  - Good example: `src/my-file.ts` and `src/my-file.test.ts`
  - Bad example: `src/my-file.ts` and `src/test/my-file.test.ts` or `test/my-file.test.ts` or `src/__tests__/my-file.test.ts`
- Tests should be run with `bun run test` (you can't do just `bun test`)
- **NEVER** add custom timeouts to individual tests or suites (e.g., `jest.setTimeout`, `test.setTimeout`, `vi.setTimeout`, or similar). This restriction applies to all test types—including unit, integration, and snapshot tests. Timeouts slow the suite and can hide performance regressions—fix the underlying issue instead of increasing the timeout.
- It's acceptable to use `any`/`unknown` in test files (such as `*.test.ts`) or test fixtures (like `**/test-data.ts`) to facilitate mocking or stubbing external modules or partial function arguments, referencing the usage guidelines in the TypeScript section. However, do not use `any` or `unknown` in production code.
  - `any` is particularly useful for unit testing functions that accept complex arguments yet only use some of them. For example, rather than correctly type out every property of a GitHub event for a function that just reads the `action` property, just pass in an object typed `any` with only the properties that get used.
