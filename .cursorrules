# IMPORTANT
- Do not ask me permission to proceed with changes. Do it.
- Run `bun run ci` after you make changes
- Use components from `src/components/ui` whenever possible
- use `import { toast } from "sonner";` and `toast(name, {description})`
- Do not use `await fetch()` to call Supabase functions, use the `await supabase.functions.invoke()`

# Coding Instructions

This documentation is intended to provide comprehensive guidelines for contributing to the codebase.
It outlines the tools, environment, coding standards, and best practices that ensure our code
remains clean, maintainable, and efficient.

## General

- Write elegant, concise, and readable code
- Prefer `const` over `let` (never use `var`)
- Use kebab-case for file and directory names
- Use clear, descriptive names for variables, functions, and components

## Modules

## TypeScript

- NEVER use `any`/`unknown` or cast values like `(value as any)` or `value!` in TypeScript outside of test files e.g. `*.test.ts` or test fixtures e.g. `**/test-data.ts`.
  - Exception: It's ok to use `any` in generic types like `interface Tool<T extends z.ZodTypeAny = any>`
  - Exception: It is also acceptable to use `Record<string, unknown>` **only** for fields intended to carry arbitrary debugging metadata (commonly named `debug`, `debugInfo`, or similar). These objects exist solely for troubleshooting—such as rendering a raw JSON dump in the UI or emitting the data directly to logs—and are therefore exempt from the general prohibition on `unknown`. All other production-code usage of `unknown` remains disallowed.
- NEVER use TypeScript enums. Instead, use unions of literal types which avoid the runtime issues associated with enums.
- Don't rely on `typeof`, `ReturnType<>`, `Awaited<>`, etc for complex type inference (it's ok for simple types)
- Use `as const` for better type inference
- Use type guards to narrow types in conditional blocks
- Create custom types for complex data structures used throughout the application
- Utilize TypeScript's utility types (e.g., `Partial`, `Pick`, `Omit`) to manipulate existing types
- Never use `React.FC`. Use a function declaration instead
- Functions should accept an object parameter (like `args` or `props`) instead of multiple parameters
  - Good examples:
    ```ts
    function myFunction(args: { foo: boolean; bar: string }) {}
    function VideoPlayer(props: { sid: string }) {}
    ```
  - Bad examples:
    ```ts
    function myFunction(foo: boolean, bar: string, baz: number) {}
    ```
- Arguments should be destructured in the function body, not the function definition. It's ok for React components to destructure props in the function definition.
  - Good example:
    ```ts
    function myFunction(args: { foo: boolean; bar: string }) {
      const { foo, bar } = args;
    }
    ```
  - Bad example:
    ```ts
    function myFunction({ foo, bar }: { foo: boolean; bar: string });
    ```
- Zod should be used to parse untrusted data, but not for data that is trusted like function arguments
- Zod unions should always be used instead of enums
  - For example, this union `z.union([z.literal('foo'), z.literal('bar')])` is better than this enum `z.enum(['foo', 'bar'])`
- Promises (and `async` functions which implicitly create Promises) must always be properly handled, either via:
  - Using `await` to wait for the Promise to resolve successfully
  - Using `.then` or `.catch` to handle Promise resolution
  - Returning a Promise to a calling function which itself has to handle the Promise. If you can't infer this from the available context, add a warning that the promise may not be handled properly.
- Use `Promise.all()` for multiple independent async operations instead of sequential execution. For example, rather than `const foo = await getFoo(); const bar = await getBar();` (sequential), use `const [foo, bar] = await Promise.all([getFoo(), getBar()]);` (parallel) for better performance.

# Lint and Fixing

Run `bun run lint && bun run fix` after changes to code; fix the errors if any.
